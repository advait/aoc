// Generated by BUCKLESCRIPT VERSION 4.0.18, PLEASE EDIT WITH CARE
'use strict';

var Fs = require("fs");
var $$Map = require("bs-platform/lib/js/map.js");
var Curry = require("bs-platform/lib/js/curry.js");
var $$String = require("bs-platform/lib/js/string.js");
var Caml_obj = require("bs-platform/lib/js/caml_obj.js");
var Caml_array = require("bs-platform/lib/js/caml_array.js");
var Caml_int32 = require("bs-platform/lib/js/caml_int32.js");
var Caml_option = require("bs-platform/lib/js/caml_option.js");
var Caml_string = require("bs-platform/lib/js/caml_string.js");
var Caml_builtin_exceptions = require("bs-platform/lib/js/caml_builtin_exceptions.js");

var text = Fs.readFileSync("test.txt", "utf8");

var re = new RegExp("(^.+$)", "gm");

function map_gen(f, g, param) {
  return Curry._1(f, Curry._1(g, /* () */0));
}

function fold_gen(f, _start, g) {
  while(true) {
    var start = _start;
    var match = Curry._1(g, /* () */0);
    if (match !== undefined) {
      _start = Curry._2(f, start, Caml_option.valFromOption(match));
      continue ;
    } else {
      return start;
    }
  };
}

function gen_lines(param, param$1) {
  var match = re.exec(text);
  if (match !== null) {
    return Caml_option.nullable_to_opt(Caml_array.caml_array_get(match, 0));
  }
  
}

function lines(param) {
  return gen_lines(/* () */0, param);
}

function compare(a, b) {
  var diff = a - b | 0;
  if (diff > 0) {
    return 1;
  } else if (diff < 0) {
    return -1;
  } else {
    return 0;
  }
}

var OrderedChar = /* module */[/* compare */compare];

var CharMap = $$Map.Make(OrderedChar);

function get_char_map(s) {
  var _s = s;
  var _acc = CharMap[/* empty */0];
  while(true) {
    var acc = _acc;
    var s$1 = _s;
    if (s$1 === "") {
      return acc;
    } else {
      var c = Caml_string.get(s$1, 0);
      var acc_;
      var exit = 0;
      var count;
      try {
        count = Curry._2(CharMap[/* find */21], c, acc);
        exit = 1;
      }
      catch (exn){
        if (exn === Caml_builtin_exceptions.not_found) {
          acc_ = Curry._3(CharMap[/* add */3], c, 1, acc);
        } else {
          throw exn;
        }
      }
      if (exit === 1) {
        acc_ = Curry._3(CharMap[/* add */3], c, count + 1 | 0, acc);
      }
      var s_ = $$String.sub(s$1, 1, s$1.length - 1 | 0);
      _acc = acc_;
      _s = s_;
      continue ;
    }
  };
}

function has_n(n, m) {
  if (Curry._2(CharMap[/* exists */12], (function (param, count) {
            return Caml_obj.caml_equal(n, count);
          }), m)) {
    return 1;
  } else {
    return 0;
  }
}

function has_two_three(m) {
  return /* tuple */[
          has_n(2, m),
          has_n(3, m)
        ];
}

function tp(a, b) {
  return /* tuple */[
          a[0] + b[0] | 0,
          a[1] + b[1] | 0
        ];
}

function counts(param) {
  var o = lines(/* () */0);
  if (o !== undefined) {
    return Caml_option.some(get_char_map(o));
  }
  
}

var match = fold_gen((function (acc, m) {
        return tp(acc, has_two_three(m));
      }), /* tuple */[
      0,
      0
    ], counts);

var threes = match[1];

var twos = match[0];

console.log(twos);

console.log(threes);

console.log(Caml_int32.imul(twos, threes));

exports.text = text;
exports.re = re;
exports.map_gen = map_gen;
exports.fold_gen = fold_gen;
exports.gen_lines = gen_lines;
exports.lines = lines;
exports.OrderedChar = OrderedChar;
exports.CharMap = CharMap;
exports.get_char_map = get_char_map;
exports.has_n = has_n;
exports.has_two_three = has_two_three;
exports.tp = tp;
exports.counts = counts;
exports.twos = twos;
exports.threes = threes;
/* text Not a pure module */
