// Generated by BUCKLESCRIPT VERSION 4.0.18, PLEASE EDIT WITH CARE
'use strict';

var Fs = require("fs");
var List = require("bs-platform/lib/js/list.js");
var Js_exn = require("bs-platform/lib/js/js_exn.js");
var Belt_List = require("bs-platform/lib/js/belt_List.js");
var Belt_Array = require("bs-platform/lib/js/belt_Array.js");
var Belt_Option = require("bs-platform/lib/js/belt_Option.js");
var Caml_option = require("bs-platform/lib/js/caml_option.js");
var Belt_MapString = require("bs-platform/lib/js/belt_MapString.js");
var Caml_primitive = require("bs-platform/lib/js/caml_primitive.js");
var Caml_builtin_exceptions = require("bs-platform/lib/js/caml_builtin_exceptions.js");

var text = Fs.readFileSync("../inputs/7.txt", "utf8");

var lines = Belt_List.fromArray(text.trim().split("\n"));

var re = new RegExp("^Step ([A-Z]) must be finished before step ([A-Z]) can begin.$");

function unwrap(v) {
  return Belt_Option.getExn((v == null) ? undefined : Caml_option.some(v));
}

function re_match(s, re) {
  var match = re.exec(s);
  if (match !== null) {
    var cap = Belt_Array.map(match, unwrap);
    return Belt_Option.getExn(Belt_List.tail(Belt_List.fromArray(cap)));
  } else {
    return /* [] */0;
  }
}

var depList = Belt_List.map(lines, (function (s) {
        var match = re_match(s, re);
        if (match) {
          var match$1 = match[1];
          if (match$1 && !match$1[1]) {
            return /* tuple */[
                    match[0],
                    match$1[0]
                  ];
          } else {
            return Js_exn.raiseError("Invalid input");
          }
        } else {
          return Js_exn.raiseError("Invalid input");
        }
      }));

var allDeps = Belt_List.reduce(depList, Belt_MapString.empty, (function (acc, entry) {
        var target = entry[1];
        var dep = entry[0];
        var deps = Belt_MapString.getWithDefault(acc, target, /* [] */0);
        var acc$1 = Belt_MapString.set(acc, target, /* :: */[
              dep,
              deps
            ]);
        if (Belt_MapString.has(acc$1, dep)) {
          return acc$1;
        } else {
          return Belt_MapString.set(acc$1, dep, /* [] */0);
        }
      }));

function compareDepEntries(e1, e2) {
  var n = Caml_primitive.caml_int_compare(Belt_List.length(e1[1]), Belt_List.length(e2[1]));
  if (n !== 0) {
    return n;
  } else {
    return Caml_primitive.caml_string_compare(e1[0], e2[0]);
  }
}

function visitOrder(deps) {
  if (Belt_MapString.isEmpty(deps)) {
    return /* [] */0;
  } else {
    var match = Belt_List.headExn(Belt_List.sort(Belt_MapString.toList(deps), compareDepEntries));
    var nextNode = match[0];
    if (match[1] !== /* [] */0) {
      throw [
            Caml_builtin_exceptions.assert_failure,
            /* tuple */[
              "advent7.re",
              72,
              4
            ]
          ];
    }
    var deps$1 = Belt_MapString.remove(deps, nextNode);
    var deps$2 = Belt_MapString.map(deps$1, (function (l) {
            return List.filter((function (n) {
                            return n !== nextNode;
                          }))(l);
          }));
    return /* :: */[
            nextNode,
            visitOrder(deps$2)
          ];
  }
}

console.log(Belt_List.toArray(visitOrder(allDeps)).join(""));

var StringMap = 0;

exports.text = text;
exports.lines = lines;
exports.re = re;
exports.unwrap = unwrap;
exports.re_match = re_match;
exports.depList = depList;
exports.StringMap = StringMap;
exports.allDeps = allDeps;
exports.compareDepEntries = compareDepEntries;
exports.visitOrder = visitOrder;
/* text Not a pure module */
