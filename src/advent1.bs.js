// Generated by BUCKLESCRIPT VERSION 4.0.18, PLEASE EDIT WITH CARE
'use strict';

var Fs = require("fs");
var $$Set = require("bs-platform/lib/js/set.js");
var List = require("bs-platform/lib/js/list.js");
var Curry = require("bs-platform/lib/js/curry.js");
var Caml_array = require("bs-platform/lib/js/caml_array.js");
var Caml_format = require("bs-platform/lib/js/caml_format.js");
var Caml_option = require("bs-platform/lib/js/caml_option.js");
var Caml_builtin_exceptions = require("bs-platform/lib/js/caml_builtin_exceptions.js");

var text = Fs.readFileSync("test.txt", "utf8");

var re = new RegExp("(^.+$)", "gm");

function map_gen(f, g, param) {
  return Curry._1(f, Curry._1(g, /* () */0));
}

function gen_lines(param, param$1) {
  var match = re.exec(text);
  if (match !== null) {
    return Caml_option.nullable_to_opt(Caml_array.caml_array_get(match, 0));
  }
  
}

function lines(param) {
  return gen_lines(/* () */0, param);
}

function ints(param) {
  var o = lines(/* () */0);
  if (o !== undefined) {
    return Caml_format.caml_int_of_string(o);
  }
  
}

function sum_gen(g) {
  var _i = 0;
  while(true) {
    var i = _i;
    var match = Curry._1(g, /* () */0);
    if (match !== undefined) {
      _i = i + match | 0;
      continue ;
    } else {
      return i;
    }
  };
}

console.log(sum_gen(ints));

function gen_to_list(g) {
  var aux = function (_acc) {
    while(true) {
      var acc = _acc;
      var match = Curry._1(g, /* () */0);
      if (match !== undefined) {
        _acc = /* :: */[
          Caml_option.valFromOption(match),
          acc
        ];
        continue ;
      } else {
        return acc;
      }
    };
  };
  return List.rev(aux(/* [] */0));
}

function infinite_iter(g) {
  var original_l = gen_to_list(g);
  var l = /* record */[/* contents */original_l];
  return (function (param) {
      if (l[0] === /* [] */0) {
        l[0] = original_l;
      }
      var match = l[0];
      if (match) {
        l[0] = match[1];
        return match[0];
      } else {
        throw Caml_builtin_exceptions.not_found;
      }
    });
}

var infinite_ints = infinite_iter(ints);

function compare(a, b) {
  var diff = a - b | 0;
  if (diff > 0) {
    return 1;
  } else if (diff < 0) {
    return -1;
  } else {
    return 0;
  }
}

var OrderedInt = /* module */[/* compare */compare];

var IntSet = $$Set.Make(OrderedInt);

function repeats(_cur, _visited, l) {
  while(true) {
    var visited = _visited;
    var cur = _cur;
    if (Curry._2(IntSet[/* mem */2], cur, visited)) {
      return cur;
    } else {
      var visited_ = Curry._2(IntSet[/* add */3], cur, visited);
      _visited = visited_;
      _cur = cur + Curry._1(l, /* () */0) | 0;
      continue ;
    }
  };
}

console.log(repeats(0, IntSet[/* empty */0], infinite_ints));

exports.text = text;
exports.re = re;
exports.map_gen = map_gen;
exports.gen_lines = gen_lines;
exports.lines = lines;
exports.ints = ints;
exports.sum_gen = sum_gen;
exports.gen_to_list = gen_to_list;
exports.infinite_iter = infinite_iter;
exports.infinite_ints = infinite_ints;
exports.OrderedInt = OrderedInt;
exports.IntSet = IntSet;
exports.repeats = repeats;
/* text Not a pure module */
