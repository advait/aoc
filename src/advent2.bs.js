// Generated by BUCKLESCRIPT VERSION 4.0.18, PLEASE EDIT WITH CARE
'use strict';

var Fs = require("fs");
var $$Map = require("bs-platform/lib/js/map.js");
var List = require("bs-platform/lib/js/list.js");
var Curry = require("bs-platform/lib/js/curry.js");
var $$String = require("bs-platform/lib/js/string.js");
var Caml_obj = require("bs-platform/lib/js/caml_obj.js");
var Caml_array = require("bs-platform/lib/js/caml_array.js");
var Caml_int32 = require("bs-platform/lib/js/caml_int32.js");
var Caml_option = require("bs-platform/lib/js/caml_option.js");
var Caml_string = require("bs-platform/lib/js/caml_string.js");
var Caml_builtin_exceptions = require("bs-platform/lib/js/caml_builtin_exceptions.js");

var text = Fs.readFileSync("test.txt", "utf8");

var re = new RegExp("(^.+$)", "gm");

function map_gen(f, g, param) {
  return Curry._1(f, Curry._1(g, /* () */0));
}

function fold_gen(f, _start, g) {
  while(true) {
    var start = _start;
    var match = Curry._1(g, /* () */0);
    if (match !== undefined) {
      _start = Curry._2(f, start, Caml_option.valFromOption(match));
      continue ;
    } else {
      return start;
    }
  };
}

function gen_lines(param, param$1) {
  var match = re.exec(text);
  if (match !== null) {
    return Caml_option.nullable_to_opt(Caml_array.caml_array_get(match, 0));
  }
  
}

function gen_to_list(g) {
  var aux = function (_acc) {
    while(true) {
      var acc = _acc;
      var match = Curry._1(g, /* () */0);
      if (match !== undefined) {
        _acc = /* :: */[
          Caml_option.valFromOption(match),
          acc
        ];
        continue ;
      } else {
        return acc;
      }
    };
  };
  return List.rev(aux(/* [] */0));
}

function list_to_gen(l) {
  var r = /* record */[/* contents */l];
  return (function (param) {
      var match = r[0];
      if (match) {
        r[0] = match[1];
        return Caml_option.some(match[0]);
      }
      
    });
}

var lines = gen_to_list((function (param) {
        return gen_lines(/* () */0, param);
      }));

function compare(a, b) {
  var diff = a - b | 0;
  if (diff > 0) {
    return 1;
  } else if (diff < 0) {
    return -1;
  } else {
    return 0;
  }
}

var OrderedChar = /* module */[/* compare */compare];

var CharMap = $$Map.Make(OrderedChar);

function get_char_map(s) {
  var _s = s;
  var _acc = CharMap[/* empty */0];
  while(true) {
    var acc = _acc;
    var s$1 = _s;
    if (s$1 === "") {
      return acc;
    } else {
      var c = Caml_string.get(s$1, 0);
      var acc_;
      var exit = 0;
      var count;
      try {
        count = Curry._2(CharMap[/* find */21], c, acc);
        exit = 1;
      }
      catch (exn){
        if (exn === Caml_builtin_exceptions.not_found) {
          acc_ = Curry._3(CharMap[/* add */3], c, 1, acc);
        } else {
          throw exn;
        }
      }
      if (exit === 1) {
        acc_ = Curry._3(CharMap[/* add */3], c, count + 1 | 0, acc);
      }
      var s_ = $$String.sub(s$1, 1, s$1.length - 1 | 0);
      _acc = acc_;
      _s = s_;
      continue ;
    }
  };
}

function has_n(n, m) {
  if (Curry._2(CharMap[/* exists */12], (function (param, count) {
            return Caml_obj.caml_equal(n, count);
          }), m)) {
    return 1;
  } else {
    return 0;
  }
}

function has_two_three(m) {
  return /* tuple */[
          has_n(2, m),
          has_n(3, m)
        ];
}

function tp(a, b) {
  return /* tuple */[
          a[0] + b[0] | 0,
          a[1] + b[1] | 0
        ];
}

var partial_arg = list_to_gen(lines);

function counts(param) {
  var o = Curry._1(partial_arg, /* () */0);
  if (o !== undefined) {
    return Caml_option.some(get_char_map(o));
  }
  
}

var match = fold_gen((function (acc, m) {
        return tp(acc, has_two_three(m));
      }), /* tuple */[
      0,
      0
    ], counts);

var threes = match[1];

var twos = match[0];

console.log(twos);

console.log(threes);

console.log(Caml_int32.imul(twos, threes));

function comp_boxes(a, b) {
  if (a === "" || b === "") {
    return 0;
  } else {
    var a_ = $$String.sub(a, 1, a.length - 1 | 0);
    var b_ = $$String.sub(b, 1, b.length - 1 | 0);
    var remaining = comp_boxes(a_, b_);
    var match = Caml_string.get(a, 0) === Caml_string.get(b, 0);
    if (match) {
      return remaining;
    } else {
      return 1 + remaining | 0;
    }
  }
}

var sorted_lines = List.sort($$String.compare, lines);

function one_comp(_lines) {
  while(true) {
    var lines = _lines;
    if (lines) {
      var match = lines[1];
      if (match) {
        var b = match[0];
        var a = lines[0];
        var diff = comp_boxes(a, b);
        if (diff === 1) {
          return /* tuple */[
                  a,
                  b
                ];
        } else {
          _lines = /* :: */[
            b,
            match[1]
          ];
          continue ;
        }
      } else {
        throw Caml_builtin_exceptions.not_found;
      }
    } else {
      throw Caml_builtin_exceptions.not_found;
    }
  };
}

console.log(one_comp(sorted_lines));

exports.text = text;
exports.re = re;
exports.map_gen = map_gen;
exports.fold_gen = fold_gen;
exports.gen_lines = gen_lines;
exports.gen_to_list = gen_to_list;
exports.list_to_gen = list_to_gen;
exports.lines = lines;
exports.OrderedChar = OrderedChar;
exports.CharMap = CharMap;
exports.get_char_map = get_char_map;
exports.has_n = has_n;
exports.has_two_three = has_two_three;
exports.tp = tp;
exports.counts = counts;
exports.twos = twos;
exports.threes = threes;
exports.comp_boxes = comp_boxes;
exports.sorted_lines = sorted_lines;
exports.one_comp = one_comp;
/* text Not a pure module */
