;; The Decent Base library
; ------------------------------------------------------------------------------

; Core macros
; ------------------------------------------------------------------------------

;; Creates a function with a specified name.
(defmacro defn (name params body)
  `(def! ,name (fn ,params ,body))
)

; Type-related functions
; ------------------------------------------------------------------------------

;; Returns whether the given parameter is a list.
(defn list? (l)
  (= (typeof l) 'List)
)

; Boolean functions
; ------------------------------------------------------------------------------

(defn not (a)
  (if a false true)
)

(defn != (a b)
  (not (= a b))
)

(defn and (a b)
  (if (not a)
    false
    b
  )
)

(defn or (a b)
  (not (and (not a) (not b)))
)

; Numeric functions
; ------------------------------------------------------------------------------

(defn <= (a b)
  (or (< a b) (= a b))
)

(defn >= (a b)
  (or (> a b) (= a b))
)

; List functions
; ------------------------------------------------------------------------------

;; Returns whether the given list is empty.
(defn empty? (l)
  (= 0 (count l))
)

;; Drops n characters from the given list or string.
(defn drop (s n)
  (if (or (<= n 0) (empty? s))
    s
    (drop (tail s) (- n 1))
  )
)

;; Takes n characters from the front of the given list or string.
(defn take (s n)
  (if (or (<= n 0) (empty? s))
    ""
    (cons
      (head s)
      (take (tail s) (- n 1)))
  )
)

;; Returns the nth element of the list or string.
(defn nth (l n)
  (if (>= n (count l))
    (error "Out of bounds")
    (head (drop l n))
  )
)

;; Applies the map function to every item in the list.
(defn map (f l)
  (if (= 0 (count l))
    ()
    (cons (f (head l)) (map f (tail l)))
  )
)

;; Filters items in the list that match the given predicate.
(defn filter (pred l)
  (if (empty? l)
    ()
    (let (h (head l))
      (if (pred h)
        (cons h (filter pred (tail l)))
        (filter pred (tail l))
      )
    )
  )
)

; String functions
; ------------------------------------------------------------------------------

; TODO: Support char literals
(def! newline (head "\n"))

;; Returns whether the given string starts with the given prefix.
(defn starts-with (haystack needle)
  (= needle (take haystack (count needle)))
)

;; Splits the given string by the separator.
(defn split (s sep)
  (let
    (rec (fn (acc s')
      (if (= "" s')
        `(,acc)
        (if (starts-with s' sep)
          (cons acc (split (drop s' (count sep)) sep))
          (rec (concat acc (take s' 1)) (tail s'))
        )
      )
    ))
    (rec "" s)
  )
)
